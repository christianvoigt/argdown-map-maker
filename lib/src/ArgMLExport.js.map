{"version":3,"sources":["../../src/ArgMLExport.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ArgMLExport.js","sourcesContent":["// import * as _ from 'lodash';\n// //import {EquivalenceClass} from 'argdown-parser';\n// var builder = require('xmlbuilder');\n// var Chance = require('chance');\n// var chance = new Chance();\n\n// class ArgMLExport{\n//   set config(config){\n//     let previousSettings = this.settings;\n//     if(!previousSettings){\n//       previousSettings = {\n//         convertToString: true\n//       };\n//     }\n//     this.settings = _.defaultsDeep({}, config, previousSettings);\n//   }\n//   constructor(config){\n//     this.name = \"ArgMLExport\";\n//     this.config = config;\n//   }\n//   run(data){\n//     if(data.config){\n//       if(data.config.argml){\n//         this.config = data.config.argml;\n//       }else if(data.config.ArgMLExport){\n//         this.config = data.config.ArgMLExport;\n//       }\n//     }\n//     if(!data.map || !data.statements || !data.arguments){\n//       return data;\n//     }\n    \n//     let argml = builder.create('graphml',{version: '1.0',\n// encoding: 'UTF-8',\n// standalone: true})\n//       .a('xmlns' , 'http://graphml.graphdrawing.org/xmlns')\n//       .a('xmlns:arg' , 'xmlns:arg=\"http://www.argunet.org/xml/argml')\n//       .a('xmlns:xsi' , 'http://www.w3.org/2001/XMLSchema-instance')\n//       .a('xmlns:y'  , 'http://www.yworks.com/xml/graphml')\n//       .a('xsi:schemaLocation' , 'http://www.argunet.org/xml/argml argunetxml.xsd http://graphml.graphdrawing.org/xmlns http://www.yworks.com/xml/schema/graphml/1.1/ygraphml.xsd');\n\n//       argml.e('key',{\n//         'attr.name' :  'arg.debate',\n//         'id' : 'd0'\n//       });\n//       argml.e('key',{\n//         'for' : 'graphml',\n//         'yfiles.type' :  'resources',\n//         'id' : 'd1'\n//       });\n//       argml.e('key',{\n//         'attr.name' :  'arg.node',\n//         'for' : 'node',\n//         'id' : 'd2'\n//       });\n//       argml.e('key',{\n//         'for' : 'node',\n//         'yfiles.type' :  'nodegraphics',\n//         'id' : 'd3'\n//       });\n//       argml.e('key',{\n//         'attr.name' : 'arg.edge',\n//         'for' :  'edge',\n//         'id' : 'd4'\n//       });\n//       argml.e('key',{\n//         'for' : 'edge',\n//         'yfiles.type' :  'edgegraphics',\n//         'id' : 'd5'\n//       });\n\n//     let graph = argml.e('graph',{\n//       'edgedefault' : 'directed',\n//       'id' : 'G'\n//     });\n\n//     let statementArgMLIds = {};\n//     let argumentArgMLIds = {};\n//     let nodesByTitle = {};\n//     //first we create argmlIds for every node and statement\n//     //we could do this on the fly, but this way its cleaner\n//     for(let node of data.map.nodes){\n//       nodesByTitle[node.title] = node;\n//       if(node.type == \"statement\"){\n//         node.argmlId = statementArgMLIds[node.title];\n//         if(!node.argmlId){\n//             node.argmlId = this.getId();\n//             statementArgMLIds[node.title] = node.argmlId;\n//         }\n//       }else if(node.type == \"argument\"){\n//         node.argmlId = argumentArgMLIds[node.title];\n//         if(!node.argmlId){\n//             node.argmlId = this.getId();\n//             argumentArgMLIds[node.title] = node.argmlId;\n//         }\n\n//         let argument = data.arguments[node.title];\n//         for(let statement of argument.pcs){\n//           let argmlId = statementArgMLIds[statement.title];\n//           if(!argmlId){\n//               argmlId = this.getId();\n//               statementArgMLIds[statement.title] = argmlId;\n//           }\n//         }\n//       }\n//     }\n\n//     for(let node of data.map.nodes){\n//       let nodeEl = graph.e('node',{id: node.id});\n//       let argDataEl = nodeEl.e('data',{'key':'d2'});\n\n//       if(node.type == \"statement\"){\n//         let statement = data.statements[node.title];\n//         let thesisEl = argDataEl.e('arg:thesis',{'id':node.argmlId, 'colorIndex':'0'}).e('arg:title', null, statement.label).up();\n//         let lastMember = _.last(statement.members);\n//         thesisEl.e('arg:content', null, lastMember.text);\n//         let shapeNode = nodeEl.e('data',{'key':'d3'}).e('y:shapeNode');\n//         shapeNode.e('y:Geometry',{\n//           'width':'135.0',\n//           'x':'0',\n//           'y':'0'\n//         });\n//         shapeNode.e('y:Fill',{\n//           'color':'#FFFFFF',\n//           'transparent':'false'\n//         });\n//         shapeNode.e('y:BorderStyle',{\n//           'color':'#63AEF2',\n//           'type':'line',\n//           'width':'3.0'\n//         });\n//         shapeNode.e('y:NodeLabel',{\n//           'alignment':'center',\n//           'autoSizePolicy':'node_width',\n//           'configuration':'CroppingLabel',\n//           'fontFamily':'Dialog',\n//           'fontSize':'12',\n//           'fontStyle':'plain',\n//           'hasBackgroundColor':'false',\n//           'hasLineColor':'false',\n//           'height':'0.0',\n//           'modelName':'internal',\n//           'modelPosition':'c',\n//           'textColor':'#000000',\n//           'visible':'true',\n//           'width':'135.0',\n//           x:'0.0'\n//         });\n//         shapeNode.e('y:NodeLabel',{\n//           'alignment':'center',\n//           'autoSizePolicy':'content',\n//           'fontFamily':'Arial',\n//           'fontSize':'13',\n//           'fontStyle':'bold',\n//           'hasBackgroundColor':'false',\n//           'hasLineColor':'false',\n//           'modelName':'internal',\n//           'modelPosition':'t',\n//           'textColor':'#000000',\n//           'visible':'true',\n//           'width':'118.0',\n//           'x':'8.5'\n//         },node.title);\n\n//         shapeNode.e('y:NodeLabel',{\n//           'alignment':'center',\n//           'autoSizePolicy':'content',\n//           'fontFamily':'Arial',\n//           'fontSize':'13',\n//           'fontStyle':'plain',\n//           'hasBackgroundColor':'false',\n//           'hasLineColor':'false',\n//           'modelName':'internal',\n//           'modelPosition':'b',\n//           'textColor':'#000000',\n//           'visible':'true',\n//           'width':'128.0',\n//           'x':'3.5'\n//         },lastMember.text);\n//         shapeNode.e('y:Shape',{'type':'roundrectangle'});\n\n//       }else if(node.type == \"argument\"){\n//         let argument = data.arguments[node.title];\n//         let lastDescriptionStatement = _.last(argument.descriptions.members);\n//         let description = (lastDescriptionStatement)?lastDescriptionStatement.text : \"\";\n//         let argEl = argDataEl.e('arg:argument',{\n//           'id' : node.argmlId,\n//           'colorIndex' : '0',\n//         }).e('arg:title',null,argument.title).up();\n//         argEl.e('arg:description', null, description);\n//         for(let i = 0; i < argument.pcs.length; i++){\n//           let statement = argument.pcs[i];\n//           let equivalenceClass = data.statements[statement.title];\n//           let lastMember = _.last(equivalenceClass.members);\n//           let propositionType = 'premise';\n//           let argmlId = statementArgMLIds[statement.title];\n\n//           if(statement.role == 'conclusion'){\n//             if(i == argument.pcs.length - 1){\n//               propositionType = 'conclusion';\n//             }else{\n//               propositionType = 'preliminaryConclusion';\n//             }\n//           }\n//           argEl.e('arg:proposition',{\n//             'id' : argmlId,\n//             'type' : propositionType\n//           }).e('arg:content', null, lastMember.text);\n//           //let equivalenceClass = data.statements[statement.title];\n\n//           //Hopefully the out-commented code will not be necessary in the future as ArgML will be cleaned up\n//           //Until then, not all semantic relations will be exported. In most cases, this is not a problem.\n//           // //In ArgML all semantic relations that are possibly not represented by edges, are saved in arg:proposition objects as arg:supportReference and arg:attackReference\n//           // //These are:\n//           // //1) Outgoing relations of premises and preliminiary conclusions\n//           // //2) Incoming relations of conclusions\n//           // for(let relation of equivalenceClass.relations){\n//           //   //1) save outgoing relations of premises and preliminiary conclusions\n//           //   if((propositionType == \"premise\" ||propositionType == \"preliminaryConclusion\") && relation.from == equivalenceClass){\n//           //     let referenceAttributes = {};\n//           //\n//           //     if(relation.from instanceof EquivalenceClass){\n//           //       let sourceArgmlId = statementArgMLIds[relation.from.title];\n//           //       referenceAttributes.refersToProposition = sourceArgmlId;\n//           //     }\n//           //     let sourceNode = nodesByTitle[relation.from.title];\n//           //     if(sourceNode){\n//           //       referenceAttributes.refersToNode = sourceNode.id;\n//           //       referenceAttributes.refersToArgunetNode = sourceNode.argmlId;\n//           //     }\n//           //\n//           //     if(relation.type == \"attack\"){\n//           //       propEl.e('arg:supportReference',referenceAttributes);\n//           //     }else if(relation.type == \"support\"){\n//           //       propEl.e('arg:attackReference',referenceAttributes);\n//           //     }else if(relation.type == \"contradiction\"){\n//           //       propEl.e('arg:contradictionReference',referenceAttributes);\n//           //     }\n//           //\n//           //   //2) save incoming relations of conclusions\n//           //   }else if(statement.role == \"conclusion\" && relation.to == equivalenceClass){\n//           //     let referenceAttributes = {};\n//           //\n//           //     if(relation.to instanceof EquivalenceClass){\n//           //       let targetArgmlId = statementArgMLIds[relation.to.title];\n//           //       referenceAttributes.refersToProposition = targetArgmlId;\n//           //     }\n//           //     let targetNode = nodesByTitle[relation.to.title];\n//           //     if(targetNode){\n//           //       referenceAttributes.refersToNode = targetNode.id;\n//           //       referenceAttributes.refersToArgunetNode = targetNode.argmlId;\n//           //     }\n//           //\n//           //     if(relation.type == \"attack\"){\n//           //       propEl.e('arg:supportReference',referenceAttributes);\n//           //     }else if(relation.type == \"support\"){\n//           //       propEl.e('arg:attackReference',referenceAttributes);\n//           //     }else if(relation.type == \"contradiction\"){\n//           //       propEl.e('arg:contradictionReference',referenceAttributes);\n//           //     }\n//           //\n//           //   }\n//           // }\n//         }\n//         let shapeNode = nodeEl.e('data',{'key':'d3'}).e('y:shapeNode');\n//         shapeNode.e('y:Geometry',{\n//           'width': '135',\n//           'x':'0',\n//           'y':'0'\n//         });\n//         shapeNode.e('y:Fill',{\n//           'color':'#63AEF2',\n//           'color2':'#82BEF5',\n//           'transparent':'false'\n//         });\n//         shapeNode.e('y:BorderStyle',{\n//           'color':'#000000',\n//           'type':'line',\n//           'width':'1.0'\n//         });\n//         shapeNode.e('y:NodeLabel',{\n//           'alignment':'center',\n//           'autoSizePolicy':'node_width',\n//           'configuration':'CroppingLabel',\n//           'fontFamily':'Dialog',\n//           'fontSize':'12',\n//           'fontStyle':'plain',\n//           'hasBackgroundColor':'false',\n//           'hasLineColor':'false',\n//           'height':'0.0',\n//           'modelName':'internal',\n//           'modelPosition':'c',\n//           'textColor':'#000000',\n//           'visible':'true',\n//           'width':'135.0',\n//           'x':'0.0'\n//         });\n//         shapeNode.e('y:NodeLabel',{\n//           'alignment':'center',\n//           'autoSizePolicy':'content',\n//           'fontFamily':'Arial',\n//           'fontSize':'13',\n//           'fontStyle':'bold',\n//           'hasBackgroundColor':'false',\n//           'hasLineColor':'false',\n//           'modelName':'internal',\n//           'modelPosition':'t',\n//           'textColor':'#000000',\n//           'visible':'true',\n//           'width':'88.0',\n//           x:'23.5'\n//         }, node.title);\n\n//         shapeNode.e('y:NodeLabel',{\n//           'alignment':'center',\n//           'autoSizePolicy':'content',\n//           'fontFamily':'Arial',\n//           'fontSize':'13',\n//           'fontStyle':'plain',\n//           'hasBackgroundColor':'false',\n//           'hasLineColor':'false',\n//           'modelName':'internal',\n//           'modelPosition':'b',\n//           'textColor':'#000000',\n//           'visible':'true',\n//           'width':'131.0',\n//           'x':'2.0'\n//         }, description);\n//         shapeNode.e('y:Shape',{'type':'roundrectangle'});\n\n//       }\n//     }\n\n//     for(let edge of data.map.edges){\n//       let edgeEl = graph.e('edge',{id:edge.id, source:edge.from.id, target:edge.to.id});\n//       let edgeType;\n//       let edgeColor = '#00FF00';\n//       if(edge.type == 'attack'){\n//         edgeColor = '#FF0000';\n//         if(edge.status == \"sketched\"){\n//           edgeType = \"sketchedAttack\";\n//         }else{\n//           edgeType = \"attack\";\n//         }\n//       }else if(edge.type == \"support\"){\n//         if(edge.status == \"sketched\"){\n//           edgeType = \"sketchedSupport\";\n//         }else{\n//           edgeType = \"support\";\n//         }\n//       }\n//       let argEdgeAttributes = {\n//         'sourceNodeId': edge.from.argmlId,\n//         'targetNodeId': edge.to.argmlId,\n//         'type': edgeType\n//       };\n//       if(edge.fromStatement){\n//         argEdgeAttributes.sourcePropositionId = statementArgMLIds[edge.fromStatement.title];\n//       }\n//       if(edge.toStatement){\n//         argEdgeAttributes.targetPropositionId = statementArgMLIds[edge.toStatement.title];\n//       }\n//       edgeEl.e('data',{'key':'d4'}).e('arg:edge', argEdgeAttributes);\n\n//       let polyLineEdge = edgeEl.e('data',{'key':'d5'}).e('y:PolyLineEdge');\n//       polyLineEdge.e('y:LineStyle',{\n//         'color':edgeColor,\n//         'type':'line',\n//         'width':'2.0'\n//       });\n//       polyLineEdge.e('y:Path',{\n//         'sx':'0',\n//         'sy':'0',\n//         'tx':'0',\n//         'ty':'0'\n//       }).e('y:Point',{'x':'0','y':'0'}).up().e('y:Point',{'x':'0','y':'0'});\n//       polyLineEdge.e('y:Arrows',{\n//         'source':'none',\n//         'target':'standard'\n//       });\n//       polyLineEdge.e('y:BendStyle', {\n//         'smoothed':'false'\n//       });\n//     }\n//     if(this.settings.convertToString){\n//       data.argml = argml.end({\n//           pretty: true,\n//           indent: '  ',\n//           newline: '\\n',\n//           allowEmpty: false\n//       });\n//     }else{\n//       data.argml = argml;\n//     }\n//     return data;\n//   }\n//   getId(){\n//     return chance.natural({min:0, max:9223372036854775807}); //positive long value\n//   }\n// }\n// module.exports = {\n//   ArgMLExport: ArgMLExport\n// }\n"]}