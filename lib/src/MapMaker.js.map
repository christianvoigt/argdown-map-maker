{"version":3,"sources":["../../src/MapMaker.js"],"names":["_","MapMaker","config","name","defaults","defaultsDeep","statementSelectionMode","argumentLabelMode","statementLabelMode","excludeDisconnected","groupMode","groupDepth","addTags","request","map","getSettings","response","makeMap","settings","nodes","edges","nodeCount","edgeCount","statementNodes","argumentNodes","relationsForMap","untitledTest","statementKeys","Object","keys","statements","statementKey","equivalenceClass","selectionTest","isConnected","relations","length","isUsedAsPremise","isUsedAsConclusion","notUsedInArgumentButWithRelations","exec","title","isUsedAsRootOfStatementTree","isUsedAsChildOfStatementTree","node","createNode","lastMember","last","members","labelText","text","isEmpty","startsWith","labelTitle","sortedTags","tags","push","relation","from","type","includes","argumentKeys","arguments","statementRoles","excludedArguments","argumentKey","hasRelations","argument","descriptions","pcs","statement","roles","premiseIn","conclusionIn","role","to","mainConclusion","froms","tos","fromNode","fromStatement","apply","toNode","toStatement","edgeId","edge","id","status","fromRoles","argumentNode","edgeType","argumentSrc","conclusion","conclusionEquivalenceClass","argumentTargetNode","nodeList","groupDict","groupList","maxGroupLevel","section","member","level","group","parent","parentGroup","currentGroup","currentSection","parentSection","minGroupLevel","nodeType","module","exports"],"mappings":"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","file":"MapMaker.js","sourcesContent":["import { Argument } from \"argdown-parser\";\nimport * as _ from \"lodash\";\nimport { Node } from \"./model/Node.js\";\nimport { Edge } from \"./model/Edge.js\";\n\nclass MapMaker {\n    constructor(config) {\n        this.name = \"MapMaker\";\n        this.defaults = _.defaultsDeep({}, config, {\n            statementSelectionMode: \"roots\", // options: all | titled | roots | statement-trees | with-relations\n            argumentLabelMode: \"hide-untitled\", // hide-untitled | title | description\n            statementLabelMode: \"hide-untitled\", // hide-untitled | title | text\n            excludeDisconnected: true,\n            groupMode: \"heading\", //options: heading | tag | none\n            groupDepth: 2,\n            addTags: true\n        });\n    }\n    getSettings(request) {\n        if (request.map) {\n            return request.map;\n        } else if (request.MapMaker) {\n            return request.MapMaker;\n        }else{\n            request.map = {};\n            return request.map;\n        }\n    }\n    prepare(request){\n        _.defaultsDeep(this.getSettings(request), this.defaults);\n    }\n    run(request, response) {\n        response.map = this.makeMap(request, response);\n        return response;\n    }\n    makeMap(request, response) {\n        const settings = this.getSettings(request);\n        const map = { nodes: [], edges: [] };\n        let nodeCount = 0; //used for generating node ids\n        let edgeCount = 0; //used for generating edge ids\n        const statementNodes = {}; //a dictionary of statement nodes. The key is the statement's title\n        const argumentNodes = {}; //a dictionary of argument nodes. The key is the argument's title\n        const relationsForMap = []; //the relations that have to be visualized by edges between nodes in the map (each relation can be represented by more than one edge)\n\n        const untitledTest = /^Untitled/;\n\n        //1) find all statement classes that should be inserted as nodes\n        //2) Add all outgoing relations of each of these statements to the relations to be represented with edges\n        let statementKeys = Object.keys(response.statements);\n        for (let statementKey of statementKeys) {\n            let equivalenceClass = response.statements[statementKey];\n            let selectionTest = true;\n\n            let isConnected =\n                equivalenceClass.relations.length > 0 ||\n                equivalenceClass.isUsedAsPremise ||\n                equivalenceClass.isUsedAsConclusion;\n            let notUsedInArgumentButWithRelations =\n                equivalenceClass.relations.length > 0 &&\n                !equivalenceClass.isUsedAsPremise &&\n                !equivalenceClass.isUsedAsConclusion;\n\n            if (settings.statementSelectionMode == \"all\") {\n                selectionTest = true;\n            }\n            if (settings.statementSelectionMode == \"titled\") {\n                selectionTest = notUsedInArgumentButWithRelations || !untitledTest.exec(equivalenceClass.title);\n            } else if (settings.statementSelectionMode == \"roots\") {\n                selectionTest = notUsedInArgumentButWithRelations || equivalenceClass.isUsedAsRootOfStatementTree;\n            } else if (settings.statementSelectionMode == \"statement-trees\") {\n                selectionTest =\n                    equivalenceClass.isUsedAsRootOfStatementTree || equivalenceClass.isUsedAsChildOfStatementTree;\n            } else if (settings.statementSelectionMode == \"with-relations\") {\n                selectionTest = equivalenceClass.relations.length > 0;\n            }\n            if ((!settings.excludeDisconnected || isConnected) && selectionTest) {\n                nodeCount++;\n                let node = this.createNode(\"statement\", statementKey, nodeCount);\n                if (settings.statementLabelMode != \"title\") {\n                    const lastMember = _.last(equivalenceClass.members);\n                    if (lastMember) {\n                        node.labelText = lastMember.text;\n                    }\n                }\n                if (settings.statementLabelMode != \"text\" || _.isEmpty(node.labelText)) {\n                    if (settings.statementLabelMode == \"title\" || !statementKey.startsWith(\"Untitled\")) {\n                        node.labelTitle = statementKey;\n                    }\n                }\n                if (settings.addTags && equivalenceClass.sortedTags) {\n                    node.tags = equivalenceClass.sortedTags;\n                }\n                statementNodes[statementKey] = node;\n                map.nodes.push(node);\n\n                //add all outgoing relations of each statement node\n                for (let relation of equivalenceClass.relations) {\n                    if (relation.from == equivalenceClass && relation.type !== \"contradictory\") {\n                        relationsForMap.push(relation);\n                    } else if (relation.type == \"contradictory\" && !_.includes(relationsForMap, relation)) {\n                        relationsForMap.push(relation);\n                    }\n                }\n            }\n        }\n\n        const argumentKeys = Object.keys(response.arguments);\n        const statementRoles = {}; //a dictionary mapping statement titles to {premiseIn:[nodeId], conclusionIn:[nodeId]} objects\n        const excludedArguments = []; // An array of all argument nodes excluded from the map in the first step\n        //1) add all (connected) arguments as argument nodes (except those that are only connected by conclusion-premise equivalence. Those will be added in the next step)\n        //2) add all outgoing relations of each argument to relationsForMap\n        //3) add all outgoing relations of each main conclusion to relationsForMap, if the conclusion is not represented by a statement node.\n        for (let argumentKey of argumentKeys) {\n            let hasRelations = false;\n            let argument = response.arguments[argumentKey];\n            nodeCount++;\n            let node = this.createNode(\"argument\", argument.title, nodeCount);\n            if (settings.argumentLabelMode != \"title\") {\n                const lastMember = _.last(argument.descriptions);\n                if (lastMember) {\n                    node.labelText = lastMember.text;\n                }\n            }\n            if (settings.argumentLabelMode != \"description\" || _.isEmpty(node.labelText)) {\n                if (!argument.title.startsWith(\"Untitled\") || settings.argumentLabelMode == \"title\") {\n                    node.labelTitle = argument.title;\n                }\n            }\n            if (settings.addTags && argument.sortedTags) {\n                node.tags = argument.sortedTags;\n            }\n\n            for (let relation of argument.relations) {\n                hasRelations = true;\n                //add all outgoing relations from each argument node\n                if (relation.from == argument) {\n                    relationsForMap.push(relation);\n                }\n            }\n            for (let statement of argument.pcs) {\n                let roles = statementRoles[statement.title];\n                let equivalenceClass = response.statements[statement.title];\n                if (!roles) {\n                    roles = { premiseIn: [], conclusionIn: [] };\n                    statementRoles[statement.title] = roles;\n                }\n                if (statementNodes[statement.title]) {\n                    //argument node has a support relation to statement node\n                    hasRelations = true;\n                }\n                if (statement.role === \"premise\") {\n                    roles.premiseIn.push(node);\n                    for (let relation of equivalenceClass.relations) {\n                        if (relation.to == equivalenceClass || relation.type === \"contradictory\") {\n                            hasRelations = true;\n                        }\n                    }\n                } else if (statement.role === \"conclusion\" && statement == _.last(argument.pcs)) {\n                    roles.conclusionIn.push(node);\n\n                    for (let relation of equivalenceClass.relations) {\n                        if (relation.from == equivalenceClass) {\n                            hasRelations = true;\n                            //add all outgoing relations of the argument's main conclusion, if the conclusion has not been inserted as a statement node\n                            //if the conclusion has been inserted as a statement node, the outgoing relations have already been added\n                            if (\n                                !statementNodes[statement.title] &&\n                                (!relation.type === \"contradictory\" || !_.includes(relationsForMap, relation))\n                            ) {\n                                relationsForMap.push(relation);\n                            }\n                        } else if (relation.type === \"contradictory\" && !_.includes(relationsForMap, relation)) {\n                            hasRelations = true;\n                            relationsForMap.push(relation);\n                        }\n                    }\n                }\n            }\n            //add argument node\n            if (!settings.excludeDisconnected || hasRelations) {\n                argumentNodes[argumentKey] = node;\n                map.nodes.push(node);\n            } else {\n                excludedArguments.push(node);\n            }\n        }\n\n        // Add arguments to map that are connected by conclusion-premise equivalence\n        // These can only be found by checking\n        // 1) for all main conclusions, if there is an equivalent statement used as premise\n        // 2) for all premises, if there is an equivalent statement used as main conclusion\n        // The latter information is only available after we built a statementRoles dictionary (statement.role only states if the statement is a conclusion, not if it is the main conclusion)\n        for (let node of excludedArguments) {\n            const argument = response.arguments[node.title];\n            const mainConclusion = _.last(argument.pcs);\n            if (argument.pcs) {\n                for (let statement of argument.pcs) {\n                    const roles = statementRoles[statement.title];\n                    if (\n                        statement.role === \"premise\" &&\n                        roles.conclusionIn &&\n                        Object.keys(roles.conclusionIn).length > 0\n                    ) {\n                        argumentNodes[argument.title] = node;\n                        map.nodes.push(node);\n                    } else if (\n                        statement.role === \"conclusion\" &&\n                        statement === mainConclusion &&\n                        roles.premiseIn &&\n                        Object.keys(roles.premiseIn).length > 0\n                    ) {\n                        argumentNodes[argument.title] = node;\n                        map.nodes.push(node);\n                    }\n                }\n            }\n        }\n\n        //Create edges representing the selected relations\n        //One relation can be represented by multiple edges in the graph, as the same sentence (the same equivalence class) can be used in several arguments as premise or conclusion.\n        //If a source/target of a relation is a statementNode, all edges, representing the relation, have to start/end at the statementNode.\n        //In the next step, \"implicit\" support edges are added that represent the equivalence relations between statements.\n        //These will connect the different occurrences of a statement (or more precisely the occurrences of an \"equivalence class\") within the graph.\n        for (let relation of relationsForMap) {\n            let froms = []; //a list of source nodes for the edges representing the relation in the graph\n            let tos = []; //a list of target nodes for the edges representing the relation in the graph\n\n            let fromNode;\n            let fromStatement;\n\n            if (relation.from instanceof Argument) {\n                fromNode = argumentNodes[relation.from.title];\n            } else {\n                fromNode = statementNodes[relation.from.title];\n                fromStatement = response.statements[relation.from.title];\n            }\n\n            if (!fromNode) {\n                //no node representing the source, so look for all arguments that use the source as conclusion\n                let roles = statementRoles[relation.from.title];\n                fromStatement = response.statements[relation.from.title];\n                if (roles) {\n                    froms.push.apply(froms, roles.conclusionIn);\n                }\n            } else {\n                //push either the argument node or the statement node to the sources list\n                froms.push(fromNode);\n            }\n\n            let toNode;\n            let toStatement;\n\n            if (relation.to instanceof Argument) {\n                toNode = argumentNodes[relation.to.title];\n            } else {\n                toNode = statementNodes[relation.to.title];\n                toStatement = response.statements[relation.to.title];\n            }\n\n            if (!toNode) {\n                //no node representing the target, so look for all arguments that use the target as premise\n                let roles = statementRoles[relation.to.title];\n                toStatement = response.statements[relation.to.title];\n                if (roles) {\n                    tos.push.apply(tos, roles.premiseIn);\n                }\n            } else {\n                //push either the argument node or the statement node to the targets list\n                tos.push(toNode);\n            }\n\n            if (relation.type == \"contradictory\") {\n                //special case: both statements of a contradictory are represented as statement nodes\n                //in this case there have to be two attack relations going both ways\n                //we have to add the \"reverse direction\" edge here\n                if (fromNode && toNode && !(fromNode instanceof Argument) && !(toNode instanceof Argument)) {\n                    let edgeId = \"e\" + edgeCount;\n                    edgeCount++;\n                    let edge = new Edge({\n                        id: edgeId,\n                        from: toNode, //node\n                        to: fromNode, //node\n                        fromStatement: toStatement, //statement\n                        toStatement: fromStatement, //statement\n                        type: \"attack\",\n                        status: \"reconstructed\"\n                    });\n                    map.edges.push(edge);\n                }\n                let fromRoles = statementRoles[relation.from.title];\n                if (fromRoles && fromRoles.premiseIn) {\n                    for (let argumentNode of fromRoles.premiseIn) {\n                        for (let to of tos) {\n                            let edgeId = \"e\" + edgeCount;\n                            edgeCount++;\n                            map.edges.push(\n                                new Edge({\n                                    id: edgeId,\n                                    from: to,\n                                    to: argumentNode,\n                                    fromStatement: toStatement,\n                                    toStatement: fromStatement,\n                                    type: \"attack\",\n                                    status: \"reconstructed\"\n                                })\n                            );\n                        }\n                    }\n                }\n            }\n\n            //now add an edge from each source to each target\n            let edgeType = relation.type;\n            if (edgeType == \"contradictory\" || edgeType == \"contrary\") {\n                edgeType = \"attack\";\n            } else if (edgeType == \"entails\") {\n                edgeType = \"support\";\n            }\n            for (let from of froms) {\n                for (let to of tos) {\n                    let edgeId = \"e\" + edgeCount;\n                    edgeCount++;\n                    map.edges.push(\n                        new Edge({\n                            id: edgeId,\n                            from: from, //node\n                            to: to, //node\n                            fromStatement: fromStatement, //statement\n                            toStatement: toStatement, //statement\n                            type: edgeType,\n                            status: relation.status\n                        })\n                    );\n                }\n            }\n        }\n\n        // Add support edges to represent equivalence relations between statement occurrences (between conclusions, premises, statement nodes)\n        // 1) From all argument nodes that use p as main conclusion to statement node p\n        // 2) From statement node p to all arguments that use p as premise\n        // 3) If p is not represented by a statement node: From all argument nodes that use p as main conclusion to all arguments that use p as premise\n        for (let node of map.nodes) {\n            if (node.type == \"statement\") {\n                let roles = statementRoles[node.title];\n                let statement = response.statements[node.title];\n                if (roles) {\n                    //1) add conclusion +> statementNode edges\n                    for (let argumentNode of roles.conclusionIn) {\n                        let edgeId = \"e\" + edgeCount;\n                        edgeCount++;\n                        map.edges.push(\n                            new Edge({\n                                id: edgeId,\n                                from: argumentNode, //node\n                                to: node, //node\n                                fromStatement: statement, //statement\n                                toStatement: statement, //statement\n                                type: \"support\",\n                                status: \"reconstructed\"\n                            })\n                        );\n                    }\n\n                    //2) add statementNode +> premise edges\n                    for (let argumentNode of roles.premiseIn) {\n                        let edgeId = \"e\" + edgeCount;\n                        edgeCount++;\n                        map.edges.push(\n                            new Edge({\n                                id: edgeId,\n                                from: node, //node\n                                to: argumentNode, //node\n                                fromStatement: statement, //statement\n                                toStatement: statement, //statement\n                                type: \"support\",\n                                status: \"reconstructed\"\n                            })\n                        );\n                    }\n                }\n            } else if (node.type == \"argument\") {\n                // 3) add support relations between argument nodes\n                const argumentSrc = response.arguments[node.title];\n                const conclusion = argumentSrc.pcs ? _.last(argumentSrc.pcs) : null;\n                if (conclusion && !statementNodes[conclusion.title]) {\n                    const conclusionEquivalenceClass = response.statements[conclusion.title];\n                    // argument is reconstructed and conclusion is not represented by statement node\n                    const roles = statementRoles[conclusion.title];\n                    if (roles && roles.premiseIn) {\n                        // argument +> argument\n                        for (let argumentTargetNode of roles.premiseIn) {\n                            let edgeId = \"e\" + edgeCount;\n                            edgeCount++;\n                            map.edges.push(\n                                new Edge({\n                                    id: edgeId,\n                                    from: node, //node\n                                    to: argumentTargetNode, //node\n                                    fromStatement: conclusionEquivalenceClass,\n                                    toStatement: conclusionEquivalenceClass,\n                                    type: \"support\",\n                                    status: \"reconstructed\"\n                                })\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        //groups\n        //groups are added to map.nodes\n        //nodes contained within a group are removed from map.nodes and pushed into group.nodes instead.\n        //groups within groups are also pushed to group.nodes.\n        if (settings.groupMode && settings.groupMode != \"none\") {\n            const nodeList = map.nodes;\n            map.nodes = [];\n\n            const groupDict = {};\n            const groupList = [];\n\n            let maxGroupLevel = 0;\n\n            for (let node of nodeList) {\n                let section = null;\n                if (node.type == \"argument\") {\n                    let argument = response.arguments[node.title];\n                    if (argument.section) {\n                        section = argument.section;\n                    } else {\n                        for (let member of argument.descriptions) {\n                            if (member.section) {\n                                section = member.section;\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    let equivalenceClass = response.statements[node.title];\n                    for (let member of equivalenceClass.members) {\n                        if (member.section) {\n                            section = member.section;\n                            break;\n                        }\n                    }\n                }\n\n                if (section) {\n                    if (maxGroupLevel < section.level) {\n                        maxGroupLevel = section.level;\n                    }\n                    let group = groupDict[section.id];\n                    if (!group) {\n                        group = {\n                            type: \"group\",\n                            id: section.id,\n                            title: section.title,\n                            labelTitle: section.title,\n                            level: section.level,\n                            nodes: []\n                        };\n                        groupDict[section.id] = group;\n                        groupList.push(group);\n                        if (section.parent) {\n                            group.parent = section.parent.id;\n                            let parentGroup = groupDict[group.parent];\n                            if (!parentGroup) {\n                                let currentGroup = group;\n                                let currentSection = section;\n                                while (currentGroup.parent) {\n                                    parentGroup = groupDict[currentGroup.parent];\n                                    if (parentGroup) {\n                                        if (!_.includes(parentGroup.nodes, currentGroup)) {\n                                            parentGroup.nodes.push(currentGroup);\n                                        }\n                                        break;\n                                    }\n                                    const parentSection = currentSection.parent;\n                                    parentGroup = {\n                                        type: \"group\",\n                                        id: parentSection.id,\n                                        title: parentSection.title,\n                                        labelTitle: parentSection.title,\n                                        level: parentSection.level,\n                                        nodes: [currentGroup]\n                                    };\n                                    if (parentSection.parent) {\n                                        parentGroup.parent = parentSection.parent.id;\n                                    }\n                                    groupDict[currentGroup.parent] = parentGroup;\n                                    groupList.push(parentGroup);\n                                    currentGroup = parentGroup;\n                                    currentSection = parentSection;\n                                }\n                            } else if (!_.includes(parentGroup.nodes, group)) {\n                                parentGroup.nodes.push(group);\n                            }\n                        }\n                    }\n                    group.nodes.push(node);\n                } else {\n                    map.nodes.push(node);\n                }\n            }\n\n            //normalize group levels\n            const minGroupLevel = maxGroupLevel - settings.groupDepth + 1;\n            for (let group of groupList) {\n                group.level = group.level - minGroupLevel;\n            }\n            for (let group of groupList) {\n                if (group.level < 0) {\n                    for (let node of group.nodes) {\n                        map.nodes.push(node);\n                    }\n                } else if (!group.parent) {\n                    map.nodes.push(group);\n                }\n            }\n        }\n\n        return map;\n    }\n    createNode(nodeType, title, nodeCount) {\n        let id = \"n\" + nodeCount;\n        return new Node(nodeType, title, id);\n    }\n}\nmodule.exports = {\n    MapMaker: MapMaker\n};\n"]}