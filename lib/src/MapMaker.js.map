{"version":3,"sources":["../../src/MapMaker.js"],"names":["_","MapMaker","config","name","request","response","map","makeMap","nodes","edges","nodeCount","edgeCount","statementNodes","argumentNodes","relationsForMap","untitledTest","statementKeys","Object","keys","statements","statementKey","equivalenceClass","selectionTest","isConnected","relations","length","isUsedAsPremise","isUsedAsConclusion","notUsedInArgumentButWithRelations","settings","statementSelectionMode","exec","title","isUsedAsRootOfStatementTree","isUsedAsChildOfStatementTree","excludeDisconnected","id","node","statementLabelMode","lastMember","last","members","labelText","text","isEmpty","startsWith","labelTitle","addTags","sortedTags","tags","push","relation","from","type","includes","argumentKeys","arguments","statementRoles","argumentKey","hasRelations","argument","argumentLabelMode","descriptions","pcs","statement","roles","premiseIn","conclusionIn","role","to","froms","tos","fromNode","fromStatement","apply","toNode","toStatement","edgeId","edge","status","fromRoles","argumentNode","edgeType","groupMode","nodeList","groupDict","groupList","maxGroupLevel","section","member","level","group","parent","parentGroup","currentGroup","currentSection","parentSection","minGroupLevel","groupDepth","previousSettings","defaultsDeep","module","exports"],"mappings":"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","file":"MapMaker.js","sourcesContent":["import { Argument } from \"argdown-parser\";\nimport * as _ from \"lodash\";\nimport { Node } from \"./model/Node.js\";\nimport { Edge } from \"./model/Edge.js\";\n\nclass MapMaker {\n    constructor(config) {\n        this.name = \"MapMaker\";\n        this.config = config;\n    }\n    set config(config) {\n        let previousSettings = this.settings;\n        if (!previousSettings) {\n            previousSettings = {\n                statementSelectionMode: \"roots\", // options: all | titled | roots | statement-trees | with-relations\n                argumentLabelMode: \"hide-untitled\", // hide-untitled | title | description\n                statementLabelMode: \"hide-untitled\", // hide-untitled | title | text\n                excludeDisconnected: true,\n                groupMode: \"heading\", //options: heading | tag | none\n                groupDepth: 2,\n                addTags: true\n            };\n        }\n        this.settings = _.defaultsDeep({}, config, previousSettings);\n    }\n    run(request, response) {\n        if (request.map) {\n            this.config = request.map;\n        } else if (request.MapMaker) {\n            this.config = request.MapMaker;\n        }\n\n        response.map = this.makeMap(response);\n        return response;\n    }\n    makeMap(response) {\n        let map = { nodes: [], edges: [] };\n        let nodeCount = 0; //used for generating node ids\n        let edgeCount = 0; //used for generating edge ids\n        let statementNodes = {}; //a dictionary of statement nodes. The key is the statement's title\n        let argumentNodes = {}; //a dictionary of argument nodes. The key is the argument's title\n        let relationsForMap = []; //the relations that have to be visualized by edges between nodes in the map (each relation can be represented by more than one edge)\n\n        const untitledTest = /^Untitled/;\n\n        //1) find all statement classes that should be inserted as nodes\n        //2) Add all outgoing relations of each of these statements to the relations to be represented with edges\n        let statementKeys = Object.keys(response.statements);\n        for (let statementKey of statementKeys) {\n            let equivalenceClass = response.statements[statementKey];\n            let selectionTest = true;\n\n            let isConnected =\n                equivalenceClass.relations.length > 0 ||\n                equivalenceClass.isUsedAsPremise ||\n                equivalenceClass.isUsedAsConclusion;\n            let notUsedInArgumentButWithRelations =\n                equivalenceClass.relations.length > 0 &&\n                !equivalenceClass.isUsedAsPremise &&\n                !equivalenceClass.isUsedAsConclusion;\n\n            if (this.settings.statementSelectionMode == \"all\") {\n                selectionTest = true;\n            }\n            if (this.settings.statementSelectionMode == \"titled\") {\n                selectionTest = notUsedInArgumentButWithRelations || !untitledTest.exec(equivalenceClass.title);\n            } else if (this.settings.statementSelectionMode == \"roots\") {\n                selectionTest = notUsedInArgumentButWithRelations || equivalenceClass.isUsedAsRootOfStatementTree;\n            } else if (this.settings.statementSelectionMode == \"statement-trees\") {\n                selectionTest =\n                    equivalenceClass.isUsedAsRootOfStatementTree || equivalenceClass.isUsedAsChildOfStatementTree;\n            } else if (this.settings.statementSelectionMode == \"with-relations\") {\n                selectionTest = equivalenceClass.relations.length > 0;\n            }\n            if ((!this.settings.excludeDisconnected || isConnected) && selectionTest) {\n                let id = \"n\" + nodeCount;\n                nodeCount++;\n                let node = new Node(\"statement\", statementKey, id);\n                if (this.settings.statementLabelMode != \"title\") {\n                    const lastMember = _.last(equivalenceClass.members);\n                    if (lastMember) {\n                        node.labelText = lastMember.text;\n                    }\n                }\n                if (this.settings.statementLabelMode != \"text\" || _.isEmpty(node.labelText)) {\n                    if (this.settings.statementLabelMode == \"title\" || !statementKey.startsWith(\"Untitled\")) {\n                        node.labelTitle = statementKey;\n                    }\n                }\n                if (this.settings.addTags && equivalenceClass.sortedTags) {\n                    node.tags = equivalenceClass.sortedTags;\n                }\n                statementNodes[statementKey] = node;\n                map.nodes.push(node);\n\n                //add all outgoing relations of each statement node\n                for (let relation of equivalenceClass.relations) {\n                    if (relation.from == equivalenceClass && relation.type !== \"contradictory\") {\n                        relationsForMap.push(relation);\n                    } else if (relation.type == \"contradictory\" && !_.includes(relationsForMap, relation)) {\n                        relationsForMap.push(relation);\n                    }\n                }\n            }\n        }\n\n        let argumentKeys = Object.keys(response.arguments);\n        let statementRoles = {}; //a dictionary mapping statement titles to {premiseIn:[nodeId], conclusionIn:[nodeId]} objects\n\n        //1) add all (connected) arguments as argument nodes\n        //2) add all outgoing relations of each argument to relationsForMap\n        //3) add all outgoing relations of each main conclusion to relationsForMap, if the conclusion is not represented by a statement node.\n        for (let argumentKey of argumentKeys) {\n            let hasRelations = false;\n            let argument = response.arguments[argumentKey];\n            let id = \"n\" + nodeCount;\n            nodeCount++;\n            let node = new Node(\"argument\", argument.title, id);\n            if (this.settings.argumentLabelMode != \"title\") {\n                const lastMember = _.last(argument.descriptions);\n                if (lastMember) {\n                    node.labelText = lastMember.text;\n                }\n            }\n            if (this.settings.argumentLabelMode != \"description\" || _.isEmpty(node.labelText)) {\n                if (!argument.title.startsWith(\"Untitled\") || this.settings.argumentLabelMode == \"title\") {\n                    node.labelTitle = argument.title;\n                }\n            }\n            if (this.settings.addTags && argument.sortedTags) {\n                node.tags = argument.sortedTags;\n            }\n\n            for (let relation of argument.relations) {\n                hasRelations = true;\n                //add all outgoing relations from each argument node\n                if (relation.from == argument) {\n                    relationsForMap.push(relation);\n                }\n            }\n            for (let statement of argument.pcs) {\n                let roles = statementRoles[statement.title];\n                let equivalenceClass = response.statements[statement.title];\n                if (!roles) {\n                    roles = { premiseIn: [], conclusionIn: [] };\n                    statementRoles[statement.title] = roles;\n                }\n                if (statementNodes[statement.title]) {\n                    //argument node has a support relation to statement node\n                    hasRelations = true;\n                }\n                if (statement.role == \"premise\") {\n                    roles.premiseIn.push(node);\n                    for (let relation of equivalenceClass.relations) {\n                        if (relation.to == equivalenceClass || relation.type == \"contradictory\") {\n                            hasRelations = true;\n                        }\n                    }\n                } else if (statement.role == \"conclusion\" && statement == argument.pcs[argument.pcs.length - 1]) {\n                    roles.conclusionIn.push(node);\n\n                    for (let relation of equivalenceClass.relations) {\n                        if (relation.from == equivalenceClass) {\n                            hasRelations = true;\n                            //add all outgoing relations of the argument's main conclusion, if the conclusion has not been inserted as a statement node\n                            //if the conclusion has been inserted as a statement node, the outgoing relations have already been added\n                            if (\n                                !statementNodes[statement.title] &&\n                                (!relation.type == \"contradictory\" || !_.includes(relationsForMap, relation))\n                            ) {\n                                relationsForMap.push(relation);\n                            }\n                        } else if (relation.type == \"contradictory\" && !_.includes(relationsForMap, relation)) {\n                            hasRelations = true;\n                            relationsForMap.push(relation);\n                        }\n                    }\n                }\n            }\n            //add argument node\n            if (!this.settings.excludeDisconnected || hasRelations) {\n                argumentNodes[argumentKey] = node;\n                map.nodes.push(node);\n            }\n        }\n\n        //Create edges representing the selected relations\n        //One relation can be represented by multiple edges in the graph, as the same sentence (the same equivalence class) can be used in several arguments as premise or conclusion.\n        //If a source/target of a relation is a statementNode, all edges, representing the relation, have to start/end at the statementNode.\n        //In the next step, \"implicit\" support edges are added that represent the equivalence relations between statements.\n        //These will connect the different occurrences of a statement (or more precisely the occurrences of an \"equivalence class\") within the graph.\n        for (let relation of relationsForMap) {\n            let froms = []; //a list of source nodes for the edges representing the relation in the graph\n            let tos = []; //a list of target nodes for the edges representing the relation in the graph\n\n            let fromNode;\n            let fromStatement;\n\n            if (relation.from instanceof Argument) {\n                fromNode = argumentNodes[relation.from.title];\n            } else {\n                fromNode = statementNodes[relation.from.title];\n                fromStatement = response.statements[relation.from.title];\n            }\n\n            if (!fromNode) {\n                //no node representing the source, so look for all arguments that use the source as conclusion\n                let roles = statementRoles[relation.from.title];\n                fromStatement = response.statements[relation.from.title];\n                if (roles) {\n                    froms.push.apply(froms, roles.conclusionIn);\n                }\n            } else {\n                //push either the argument node or the statement node to the sources list\n                froms.push(fromNode);\n            }\n\n            let toNode;\n            let toStatement;\n\n            if (relation.to instanceof Argument) {\n                toNode = argumentNodes[relation.to.title];\n            } else {\n                toNode = statementNodes[relation.to.title];\n                toStatement = response.statements[relation.to.title];\n            }\n\n            if (!toNode) {\n                //no node representing the target, so look for all arguments that use the target as premise\n                let roles = statementRoles[relation.to.title];\n                toStatement = response.statements[relation.to.title];\n                if (roles) {\n                    tos.push.apply(tos, roles.premiseIn);\n                }\n            } else {\n                //push either the argument node or the statement node to the targets list\n                tos.push(toNode);\n            }\n\n            if (relation.type == \"contradictory\") {\n                //special case: both statements of a contradictory are represented as statement nodes\n                //in this case there have to be two attack relations going both ways\n                //we have to add the \"reverse direction\" edge here\n                if (fromNode && toNode && !(fromNode instanceof Argument) && !(toNode instanceof Argument)) {\n                    let edgeId = \"e\" + edgeCount;\n                    edgeCount++;\n                    let edge = new Edge({\n                        id: edgeId,\n                        from: toNode, //node\n                        to: fromNode, //node\n                        fromStatement: toStatement, //statement\n                        toStatement: fromStatement, //statement\n                        type: \"attack\",\n                        status: \"reconstructed\"\n                    });\n                    map.edges.push(edge);\n                }\n                let fromRoles = statementRoles[relation.from.title];\n                if (fromRoles && fromRoles.premiseIn) {\n                    for (let argumentNode of fromRoles.premiseIn) {\n                        for (let to of tos) {\n                            let edgeId = \"e\" + edgeCount;\n                            edgeCount++;\n                            map.edges.push(\n                                new Edge({\n                                    id: edgeId,\n                                    from: to,\n                                    to: argumentNode,\n                                    fromStatement: toStatement,\n                                    toStatement: fromStatement,\n                                    type: \"attack\",\n                                    status: \"reconstructed\"\n                                })\n                            );\n                        }\n                    }\n                }\n            }\n\n            //now add an edge from each source to each target\n            let edgeType = relation.type;\n            if (edgeType == \"contradictory\" || edgeType == \"contrary\") {\n                edgeType = \"attack\";\n            } else if (edgeType == \"entails\") {\n                edgeType = \"support\";\n            }\n            for (let from of froms) {\n                for (let to of tos) {\n                    let edgeId = \"e\" + edgeCount;\n                    edgeCount++;\n                    map.edges.push(\n                        new Edge({\n                            id: edgeId,\n                            from: from, //node\n                            to: to, //node\n                            fromStatement: fromStatement, //statement\n                            toStatement: toStatement, //statement\n                            type: edgeType,\n                            status: relation.status\n                        })\n                    );\n                }\n            }\n        }\n\n        //Add support edges to represent equivalence relations between sentences or sentence occurrences\n        //1) From all argument nodes that use p as main conclusion to statement node p\n        //2) From statement node p to all arguments that use p as premise\n        for (let node of map.nodes) {\n            if (node.type == \"statement\") {\n                let roles = statementRoles[node.title];\n                let statement = response.statements[node.title];\n                if (roles) {\n                    //1) add conclusion +> statementNode edges\n                    for (let argumentNode of roles.conclusionIn) {\n                        let edgeId = \"e\" + edgeCount;\n                        edgeCount++;\n                        map.edges.push(\n                            new Edge({\n                                id: edgeId,\n                                from: argumentNode, //node\n                                to: node, //node\n                                fromStatement: statement, //statement\n                                toStatement: statement, //statement\n                                type: \"support\",\n                                status: \"reconstructed\"\n                            })\n                        );\n                    }\n\n                    //2) add statementNode +> premise edges\n                    for (let argumentNode of roles.premiseIn) {\n                        let edgeId = \"e\" + edgeCount;\n                        edgeCount++;\n                        map.edges.push(\n                            new Edge({\n                                id: edgeId,\n                                from: node, //node\n                                to: argumentNode, //node\n                                fromStatement: statement, //statement\n                                toStatement: statement, //statement\n                                type: \"support\",\n                                status: \"reconstructed\"\n                            })\n                        );\n                    }\n                }\n            }\n        }\n\n        //groups\n        //groups are added to map.nodes\n        //nodes contained within a group are removed from map.nodes and pushed into group.nodes instead.\n        //groups within groups are also pushed to group.nodes.\n        if (this.settings.groupMode && this.settings.groupMode != \"none\") {\n            const nodeList = map.nodes;\n            map.nodes = [];\n\n            const groupDict = {};\n            const groupList = [];\n\n            let maxGroupLevel = 0;\n\n            for (let node of nodeList) {\n                let section = null;\n                if (node.type == \"argument\") {\n                    let argument = response.arguments[node.title];\n                    if (argument.section) {\n                        section = argument.section;\n                    } else {\n                        for (let member of argument.descriptions) {\n                            if (member.section) {\n                                section = member.section;\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    let equivalenceClass = response.statements[node.title];\n                    for (let member of equivalenceClass.members) {\n                        if (member.section) {\n                            section = member.section;\n                            break;\n                        }\n                    }\n                }\n\n                if (section) {\n                    if (maxGroupLevel < section.level) {\n                        maxGroupLevel = section.level;\n                    }\n                    let group = groupDict[section.id];\n                    if (!group) {\n                        group = {\n                            type: \"group\",\n                            id: section.id,\n                            title: section.title,\n                            labelTitle: section.title,\n                            level: section.level,\n                            nodes: []\n                        };\n                        groupDict[section.id] = group;\n                        groupList.push(group);\n                        if (section.parent) {\n                            group.parent = section.parent.id;\n                            let parentGroup = groupDict[group.parent];\n                            if (!parentGroup) {\n                                let currentGroup = group;\n                                let currentSection = section;\n                                while (currentGroup.parent) {\n                                    parentGroup = groupDict[currentGroup.parent];\n                                    if (parentGroup) {\n                                        if (!_.includes(parentGroup.nodes, currentGroup)) {\n                                            parentGroup.nodes.push(currentGroup);\n                                        }\n                                        break;\n                                    }\n                                    const parentSection = currentSection.parent;\n                                    parentGroup = {\n                                        type: \"group\",\n                                        id: parentSection.id,\n                                        title: parentSection.title,\n                                        labelTitle: parentSection.title,\n                                        level: parentSection.level,\n                                        nodes: [currentGroup]\n                                    };\n                                    if (parentSection.parent) {\n                                        parentGroup.parent = parentSection.parent.id;\n                                    }\n                                    groupDict[currentGroup.parent] = parentGroup;\n                                    groupList.push(parentGroup);\n                                    currentGroup = parentGroup;\n                                    currentSection = parentSection;\n                                }\n                            } else if (!_.includes(parentGroup.nodes, group)) {\n                                parentGroup.nodes.push(group);\n                            }\n                        }\n                    }\n                    group.nodes.push(node);\n                } else {\n                    map.nodes.push(node);\n                }\n            }\n\n            //normalize group levels\n            const minGroupLevel = maxGroupLevel - this.settings.groupDepth + 1;\n            for (let group of groupList) {\n                group.level = group.level - minGroupLevel;\n            }\n            for (let group of groupList) {\n                if (group.level < 0) {\n                    for (let node of group.nodes) {\n                        map.nodes.push(node);\n                    }\n                } else if (!group.parent) {\n                    map.nodes.push(group);\n                }\n            }\n        }\n\n        return map;\n    }\n}\nmodule.exports = {\n    MapMaker: MapMaker\n};\n"]}