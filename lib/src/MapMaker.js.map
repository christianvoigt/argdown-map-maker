{"version":3,"sources":["../../src/MapMaker.js"],"names":["_","MapMaker","config","name","data","map","makeMap","nodes","edges","nodeCount","edgeCount","statementNodes","argumentNodes","relationsForMap","untitledTest","statementKeys","Object","keys","statements","statementKey","equivalenceClass","selectionTest","settings","statementSelectionMode","relations","length","isUsedAsPremise","isUsedAsConclusion","exec","title","isUsedAsRootOfStatementTree","isUsedAsChildOfStatementTree","connectedTest","excludeDisconnected","id","node","type","push","relation","from","argumentKeys","arguments","statementRoles","argumentKey","hasRelations","argument","pcs","statement","roles","premiseIn","conclusionIn","role","to","froms","tos","fromNode","fromStatement","toNode","toStatement","edgeId","status","edgeType","argumentNode","defaults","module","exports"],"mappings":"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","file":"MapMaker.js","sourcesContent":["import {Argument} from 'argdown-parser';\nimport * as _ from 'lodash';\n\nclass MapMaker{\n  constructor(config){\n    this.name = \"MapMaker\";\n    this.config = config;\n  }\n  set config(config){\n    this.settings = _.defaults(config ||{}, {\n      statementSelectionMode : \"roots\", //options: all | titled | roots | statement-trees\n      excludeDisconnected : true\n    });\n  }\n  run(data){\n    data.map = this.makeMap(data);\n    return data;\n  }\n  makeMap(data){\n    let map = {nodes: [], edges: []};\n    let nodeCount = 0; //used for generating node ids\n    let edgeCount = 0; //used for generating edge ids\n    let statementNodes = {}; //a dictionary of statement nodes. The key is the statement's title\n    let argumentNodes = {}; //a dictionary of argument nodes. The key is the argument's title\n    let relationsForMap = []; //the relations that have to be visualized by edges between nodes in the map (each relation can be represented by more than one edge)\n\n    const untitledTest = /^Untitled/;\n\n    //1) find all statement classes that should be inserted as nodes\n    //2) Add all outgoing relations of each of these statements to the relations to be represented with edges\n    let statementKeys = Object.keys(data.statements);\n    for(let statementKey of statementKeys){\n      let equivalenceClass = data.statements[statementKey];\n      let selectionTest = true;\n\n      if(this.settings.statementSelectionMode == \"titled\"){\n        selectionTest = (equivalenceClass.relations.length > 0 && !equivalenceClass.isUsedAsPremise && !equivalenceClass.isUsedAsConclusion)\n        || !untitledTest.exec(equivalenceClass.title);\n      }else if(this.settings.statementSelectionMode == \"roots\"){\n        selectionTest = (equivalenceClass.relations.length > 0 && !equivalenceClass.isUsedAsPremise && !equivalenceClass.isUsedAsConclusion)\n        || equivalenceClass.isUsedAsRootOfStatementTree;\n      }else if(this.settings.statementSelectionMode == \"statement-trees\"){\n        selectionTest = equivalenceClass.isUsedAsRootOfStatementTree || equivalenceClass.isUsedAsChildOfStatementTree;\n      }\n      let connectedTest = !this.settings.excludeDisconnected ||equivalenceClass.relations.length > 0;\n\n      if(connectedTest && selectionTest){\n        let id = \"n\"+nodeCount;\n        nodeCount++;\n        let node = {type:\"statement\", title:statementKey, id:id};\n        statementNodes[statementKey] = node;\n        map.nodes.push(node)\n\n        //add all outgoing relations of each statement node\n        for(let relation of equivalenceClass.relations){\n          if(relation.from == equivalenceClass){\n            relationsForMap.push(relation);\n          }\n        }\n      }\n    }\n\n    let argumentKeys = Object.keys(data.arguments);\n    let statementRoles = {}; //a dictionary mapping statement titles to {premiseIn:[nodeId], conclusionIn:[nodeId]} objects\n\n    //1) add all (connected) arguments as argument nodes\n    //2) add all outgoing relations of each argument to relationsForMap\n    //3) add all outgoing relations of each main conclusion to relationsForMap, if the conclusion is not represented by a statement node.\n    for(let argumentKey of argumentKeys){\n      let hasRelations = false;\n      let argument = data.arguments[argumentKey];\n      let id = \"n\"+nodeCount;\n      nodeCount++;\n      let node = {type:\"argument\", title:argument.title, id:id};\n\n      for(let relation of argument.relations){\n        hasRelations = true;\n        //add all outgoing relations from each argument node\n        if(relation.from == argument){\n          relationsForMap.push(relation);\n        }\n      }\n      for(let statement of argument.pcs){\n        let roles = statementRoles[statement.title];\n        let equivalenceClass = data.statements[statement.title];\n        if(!roles){\n          roles = {premiseIn:[], conclusionIn:[]};\n          statementRoles[statement.title] = roles;\n        }\n        if(statement.role == \"premise\"){\n          roles.premiseIn.push(node);\n          for(let relation of equivalenceClass.relations){\n            if(relation.to == equivalenceClass){\n              hasRelations = true;\n              break;\n            }\n          }\n        }else if(statement.role == \"conclusion\" && statement == argument.pcs[argument.pcs.length - 1]){\n          roles.conclusionIn.push(node);\n\n          for(let relation of equivalenceClass.relations){\n            if(relation.from == equivalenceClass){\n              hasRelations = true;\n              //add all outgoing relations of the argument's main conclusion, if the conclusion has not been inserted as a statement node\n              //if the conclusion has been inserted as a statement node, the outgoing relations have already been added\n              if(!statementNodes[statement.title]){\n                relationsForMap.push(relation);\n              }\n\n            }\n          }\n        }\n      }\n      //add argument node\n      if(!this.settings.excludeDisconnected || hasRelations){\n        argumentNodes[argumentKey] = node;\n        map.nodes.push(node);\n      }\n    }\n\n\n    //Create edges representing the selected relations\n    //One relation can be represented by multiple edges in the graph, as the same sentence (the same equivalence class) can be used in several arguments as premise or conclusion.\n    //If a source/target of a relation is a statementNode, all edges, representing the relation, have to start/end at the statementNode.\n    //In the next step, \"implicit\" support edges are added that represent the equivalence relations between statements.\n    //These will connect the different occurrences of a statement (or more precisely an \"equivalence class\" of statements) within the graph.\n    for(let relation of relationsForMap){\n      let froms = []; //a list of source nodes for the edges representing the relation in the graph\n      let tos = []; //a list of target nodes for the edges representing the relation in the graph\n\n      let fromNode;\n      let fromStatement;\n\n      if(relation.from instanceof Argument){\n        fromNode = argumentNodes[relation.from.title];\n      }else{\n        fromNode = statementNodes[relation.from.title];\n        fromStatement = data.statements[relation.from.title];\n      }\n\n      if(!fromNode){ //no node representing the source, so look for all arguments that use the source as conclusion\n        let roles = statementRoles[relation.from.title];\n        fromStatement = data.statements[relation.from.title];\n        if(roles){\n          froms = roles.conclusionIn;\n        }\n      }else{ //push either the argument node or the statement node to the sources list\n        froms.push(fromNode);\n      }\n\n      let toNode;\n      let toStatement;\n\n      if(relation.to instanceof Argument){\n        toNode = argumentNodes[relation.to.title];\n      }else{\n        toNode = statementNodes[relation.to.title];\n        toStatement = data.statements[relation.to.title];\n      }\n\n      if(!toNode){ //no node representing the target, so look for all arguments that use the target as premise\n        let roles = statementRoles[relation.to.title];\n        toStatement = data.statements[relation.to.title];\n        if(roles){\n          tos = roles.premiseIn;\n        }\n      }else{ //push either the argument node or the statement node to the targets list\n        tos.push(toNode);\n      }\n\n      //special case: both statements of a contradiction are represented as statement nodes\n      //in this case there have to be two attack relations going both ways\n      //we have to add the \"reverse direction\" edge here\n      if(relation.type == \"contradiction\" && fromNode && toNode){\n        let edgeId = 'e'+edgeCount;\n        edgeCount++;\n        map.edges.push({\n          id:edgeId,\n          from:toNode, //node\n          to:fromNode, //node\n          fromStatement: toStatement, //statement\n          toStatement: fromStatement, //statement\n          type:\"attack\",\n          status: \"reconstructed\"\n        });\n      }\n\n      //now add an edge from each source to each target\n      let edgeType = relation.type;\n      if(edgeType == \"contradiction\"){\n        edgeType = \"attack\";\n      }\n      for(let from of froms){\n        for(let to of tos){\n          let edgeId = 'e'+edgeCount;\n          edgeCount++;\n          map.edges.push({\n            id:edgeId,\n            from:from, //node\n            to:to, //node\n            fromStatement: fromStatement, //statement\n            toStatement: toStatement, //statement\n            type:edgeType,\n            status: relation.status\n          });\n        }\n      }\n    }\n\n    //Add support edges to represent equivalence relations between sentences or sentence occurrences\n    //1) From all argument nodes that use p as main conclusion to statement node p\n    //2) From statement node p to all arguments that use p as premise\n    for(let node of map.nodes){\n      if(node.type == \"statement\"){\n        let roles = statementRoles[node.title];\n        let statement = data.statements[node.title];\n        if(roles){\n          //1) add conclusion +> statementNode edges\n          for(let argumentNode of roles.conclusionIn){\n            let edgeId = 'e'+edgeCount;\n            edgeCount++;\n            map.edges.push({\n              id:edgeId,\n              from:argumentNode, //node\n              to:node, //node\n              fromStatement: statement, //statement\n              toStatement: statement, //statement\n              type:\"support\",\n              status: \"reconstructed\"\n            });\n          }\n\n          //2) add statementNode +> premise edges\n          for(let argumentNode of roles.premiseIn){\n            let edgeId = 'e'+edgeCount;\n            edgeCount++;\n            map.edges.push({\n              id:edgeId,\n              from:node, //node\n              to:argumentNode, //node\n              fromStatement: statement, //statement\n              toStatement: statement, //statement\n              type:\"support\",\n              status: \"reconstructed\"\n            });\n          }\n        }\n      }\n    }\n\n    return map;\n  }\n}\nmodule.exports = {\n  MapMaker: MapMaker\n}\n"]}