{"version":3,"sources":["../../src/MapMaker.js"],"names":["_","MapMaker","config","name","data","map","makeMap","nodes","edges","nodeCount","edgeCount","statementNodes","argumentNodes","relationsForMap","untitledTest","statementKeys","Object","keys","statements","statementKey","equivalenceClass","selectionTest","isConnected","relations","length","isUsedAsPremise","isUsedAsConclusion","notUsedInArgumentButWithRelations","settings","statementSelectionMode","exec","title","isUsedAsRootOfStatementTree","isUsedAsChildOfStatementTree","excludeDisconnected","id","node","statementLabelMode","lastMember","last","members","labelText","text","isEmpty","startsWith","labelTitle","addTags","sortedTags","tags","push","relation","from","type","includes","argumentKeys","arguments","statementRoles","argumentKey","hasRelations","argument","argumentLabelMode","descriptions","pcs","statement","roles","premiseIn","conclusionIn","role","to","froms","tos","fromNode","fromStatement","apply","toNode","toStatement","edgeId","edge","status","fromRoles","toRoles","argumentNode","toArgument","edgeType","groupMode","nodeList","groupDict","groupList","maxGroupLevel","section","member","level","group","parent","minGroupLevel","groupDepth","parentGroup","previousSettings","defaultsDeep","module","exports"],"mappings":"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","file":"MapMaker.js","sourcesContent":["import {Argument} from 'argdown-parser';\nimport { EquivalenceClass } from 'argdown-parser';\nimport * as _ from 'lodash';\nimport {Node} from './model/Node.js';\nimport {Edge} from './model/Edge.js';\n\nclass MapMaker{\n  constructor(config){\n    this.name = \"MapMaker\";\n    this.config = config;\n  }\n  set config(config){\n    let previousSettings = this.settings;\n    if(!previousSettings){\n      previousSettings = {\n        statementSelectionMode : \"roots\", //options: all | titled | roots | statement-trees | with-relations\n        argumentLabelMode: 'hide-untitled', //hide-untitled | title | description\n        statementLabelMode: 'hide-untitled', //hide-untitled | title | text\n        excludeDisconnected : true,\n        groupMode : \"heading\", //options: heading | tag | none\n        groupDepth : 2,\n        addTags : true\n      }\n    }\n    this.settings = _.defaultsDeep({}, config, previousSettings);\n  }\n  run(data){\n    if(data.config){\n      if(data.config.map){\n        this.config = data.config.map;\n      }else if(data.config.MapMaker){\n        this.config = data.config.MapMaker;\n      }\n    }\n\n    data.map = this.makeMap(data);\n    return data;\n  }\n  makeMap(data){\n    let map = {nodes: [], edges: []};\n    let nodeCount = 0; //used for generating node ids\n    let edgeCount = 0; //used for generating edge ids\n    let statementNodes = {}; //a dictionary of statement nodes. The key is the statement's title\n    let argumentNodes = {}; //a dictionary of argument nodes. The key is the argument's title\n    let relationsForMap = []; //the relations that have to be visualized by edges between nodes in the map (each relation can be represented by more than one edge)\n\n    const untitledTest = /^Untitled/;\n\n    //1) find all equivalence classes that should be inserted as nodes\n    //2) Add all outgoing relations of each of these statements to the relations to be represented with edges\n    let statementKeys = Object.keys(data.statements);\n    for(let statementKey of statementKeys){\n      let equivalenceClass = data.statements[statementKey];\n      let selectionTest = true;\n\n      let isConnected = equivalenceClass.relations.length > 0 || equivalenceClass.isUsedAsPremise || equivalenceClass.isUsedAsConclusion;\n      let notUsedInArgumentButWithRelations = equivalenceClass.relations.length > 0 && !equivalenceClass.isUsedAsPremise && !equivalenceClass.isUsedAsConclusion;\n      \n      if(this.settings.statementSelectionMode == \"all\"){\n        selectionTest = true;\n      }if(this.settings.statementSelectionMode == \"titled\"){\n        selectionTest = notUsedInArgumentButWithRelations || !untitledTest.exec(equivalenceClass.title);\n      }else if(this.settings.statementSelectionMode == \"roots\"){\n        selectionTest = notUsedInArgumentButWithRelations || equivalenceClass.isUsedAsRootOfStatementTree;\n      }else if(this.settings.statementSelectionMode == \"statement-trees\"){\n        selectionTest = equivalenceClass.isUsedAsRootOfStatementTree || equivalenceClass.isUsedAsChildOfStatementTree;\n      }else if(this.settings.statementSelectionMode == \"with-relations\"){\n        selectionTest = equivalenceClass.relations.length > 0;        \n      }\n      if((!this.settings.excludeDisconnected ||isConnected) && selectionTest){\n        let id = \"n\"+nodeCount;\n        nodeCount++;\n        let node = new Node(\"statement\", statementKey, id);\n        if(this.settings.statementLabelMode != \"title\"){\n          const lastMember = _.last(equivalenceClass.members);\n          if(lastMember){\n            node.labelText = lastMember.text;            \n          }\n        }\n        if(this.settings.statementLabelMode != \"text\" ||_.isEmpty(node.labelText)){\n          if(this.settings.statementLabelMode == 'title' || !statementKey.startsWith('Untitled')){\n            node.labelTitle = statementKey;\n          }\n        }\n        if(this.settings.addTags && equivalenceClass.sortedTags){\n          node.tags = equivalenceClass.sortedTags;\n        }\n        statementNodes[statementKey] = node;\n        map.nodes.push(node)\n\n        //add all outgoing relations of each statement node\n        for(let relation of equivalenceClass.relations){\n          if(relation.from == equivalenceClass && relation.type !== \"contradictory\"){\n            relationsForMap.push(relation);              \n          }else if(relation.type == \"contradictory\" && !_.includes(relationsForMap, relation)){\n            relationsForMap.push(relation);\n          }\n        }\n      }\n    }\n\n    let argumentKeys = Object.keys(data.arguments);\n    let statementRoles = {}; //a dictionary mapping statement titles to {premiseIn:[nodeId], conclusionIn:[nodeId]} objects\n\n    //1) add all (connected) arguments as argument nodes\n    //2) add all outgoing relations of each argument to relationsForMap\n    //3) add all outgoing relations of each main conclusion to relationsForMap, if the conclusion is not represented by a statement node.\n    for(let argumentKey of argumentKeys){\n      let hasRelations = false;\n      let argument = data.arguments[argumentKey];\n      let id = \"n\"+nodeCount;\n      nodeCount++;\n      let node = new Node(\"argument\", argument.title, id);\n      if(this.settings.argumentLabelMode != 'title'){\n        const lastMember = _.last(argument.descriptions);\n        if(lastMember){\n          node.labelText = lastMember.text;          \n        }\n      }\n      if(this.settings.argumentLabelMode != 'description' || _.isEmpty(node.labelText)){\n        if(!argument.title.startsWith('Untitled') || this.settings.argumentLabelMode == 'title'){\n          node.labelTitle = argument.title;\n        }\n      }\n      if(this.settings.addTags && argument.sortedTags){\n        node.tags = argument.sortedTags;\n      }\n\n      for(let relation of argument.relations){\n        hasRelations = true;\n        //add all outgoing relations from each argument node\n        if(relation.from == argument){\n          relationsForMap.push(relation);\n        }\n      }\n      for(let statement of argument.pcs){\n        let roles = statementRoles[statement.title];\n        let equivalenceClass = data.statements[statement.title];\n        if(!roles){\n          roles = {premiseIn:[], conclusionIn:[]};\n          statementRoles[statement.title] = roles;\n        }\n        if(statementNodes[statement.title]){\n          //argument node has a support relation to statement node\n          hasRelations = true;\n        }\n        if(statement.role == \"premise\"){\n          roles.premiseIn.push(node);\n          for(let relation of equivalenceClass.relations){\n            if(relation.to == equivalenceClass || relation.type == \"contradictory\"){\n              hasRelations = true;\n            }\n          }\n        }else if(statement.role == \"conclusion\" && statement == argument.pcs[argument.pcs.length - 1]){ //statement is main conclusion\n          roles.conclusionIn.push(node);\n\n          for(let relation of equivalenceClass.relations){\n            if(relation.from == equivalenceClass){\n              hasRelations = true;\n              //add all outgoing relations of the argument's main conclusion, if the conclusion has not been inserted as a statement node\n              //if the conclusion has been inserted as a statement node, the outgoing relations have already been added\n              if(!statementNodes[statement.title] && (!relation.type == \"contradictory\" ||!_.includes(relationsForMap,relation))){\n                relationsForMap.push(relation);\n              }\n            }else if(relation.type == \"contradictory\" && !_.includes(relationsForMap,relation)){\n              hasRelations = true;\n              relationsForMap.push(relation);\n            }\n          }\n        }\n      }\n      //add argument node\n      if(!this.settings.excludeDisconnected || hasRelations){\n        argumentNodes[argumentKey] = node;\n        map.nodes.push(node);\n      }\n    }\n\n\n    //Create edges representing the selected relations\n    //One relation can be represented by multiple edges in the graph, as the same sentence (the same equivalence class) can be used in several arguments as premise or conclusion.\n    //If a source/target of a relation is a statementNode, all edges, representing the relation, have to start/end at the statementNode.\n    //In the next step, \"implicit\" support edges are added that represent the equivalence relations between statements.\n    //These will connect the different occurrences of a statement (or more precisely the occurrences of an \"equivalence class\") within the graph.\n    for(let relation of relationsForMap){\n      let froms = []; //a list of source nodes for the edges representing the relation in the graph\n      let tos = []; //a list of target nodes for the edges representing the relation in the graph\n      // For froms and tos there are three cases to consider: \n      // a) argumentNodes in the graph\n      // b) statementNodes in the graph\n      // c) statements that are used as premises or conclusions within argumentNode in the graph\n\n      let fromNode;\n      let fromStatement;\n\n      if(relation.from instanceof Argument){ //a) argumentNode\n        fromNode = argumentNodes[relation.from.title];\n      }else{ //b) statementNode\n        fromNode = statementNodes[relation.from.title];\n        fromStatement = data.statements[relation.from.title];\n      }\n\n      if(!fromNode){ //c): no node representing the source, so look for all arguments that use the source as conclusion\n        let roles = statementRoles[relation.from.title];\n        fromStatement = data.statements[relation.from.title];\n        if(roles && roles.conclusionIn){\n          froms.push.apply(froms, roles.conclusionIn);\n        }\n      }else{ //a) or b): push either the argument node or the statement node to the sources list\n        froms.push(fromNode);\n      }\n\n      let toNode;\n      let toStatement;\n\n      if(relation.to instanceof Argument){//a) argumentNode\n        toNode = argumentNodes[relation.to.title];\n      }else{//b) statementNode\n        toNode = statementNodes[relation.to.title];\n        toStatement = data.statements[relation.to.title];\n      }\n\n      if(!toNode){ //c): no node representing the target, so look for all arguments that use the target as premise\n        let roles = statementRoles[relation.to.title];\n        toStatement = data.statements[relation.to.title];\n        if(roles && roles.premiseIn){\n          tos.push.apply(tos, roles.premiseIn);\n        }\n      }else{ //a) or b): push either the argument node or the statement node to the targets list\n        tos.push(toNode);\n      }\n\n      if(relation.type == \"contradictory\"){\n        //special case: both statements of a contradictory relation are represented as statement nodes\n        //in this case there have to be two attack relations going both ways\n        //we have to add the \"reverse direction\" edge here\n        if(fromNode && toNode && fromNode.type == \"statement\" && toNode.type == \"statement\"){\n          let edgeId = 'e'+edgeCount;\n          edgeCount++;\n          let edge = new Edge({\n                      id:edgeId,\n                      from:toNode, //node\n                      to:fromNode, //node\n                      fromStatement: toStatement, //statement\n                      toStatement: fromStatement, //statement\n                      type:\"attack\",\n                      status: \"reconstructed\"\n                    });\n          map.edges.push(edge);         \n        }\n\n        //special case: source of a contradictory relation is a premise in an argument\n        //and target is argument or statementNode.\n        //We have to add an edge in the inverted direction\n        let fromRoles = statementRoles[relation.from.title];\n        let toRoles = statementRoles[relation.to.title];\n        if(fromRoles && fromRoles.premiseIn){\n          for(let argumentNode of fromRoles.premiseIn){\n            if(toNode && toNode.type == \"statement\"){ // toNode is statementNode\n              let edgeId = 'e' + edgeCount;\n              edgeCount++;\n              map.edges.push(new Edge({\n                id: edgeId,\n                from: toNode,\n                to: argumentNode,\n                fromStatement: toStatement,\n                toStatement: fromStatement,\n                type: \"attack\",\n                status: \"reconstructed\"\n              }));\n            }else if(toRoles && toRoles.conclusionIn){ // there are arguments that have the to statement as conclusion\n              for(let toArgument of toRoles.conclusionIn){\n                let edgeId = 'e' + edgeCount;\n                edgeCount++;\n                map.edges.push(new Edge({\n                  id: edgeId,\n                  from: toArgument,\n                  to: argumentNode,\n                  fromStatement: toStatement,\n                  toStatement: fromStatement,\n                  type: \"attack\",\n                  status: \"reconstructed\"\n                }));\n              }\n            }\n          }\n        }\n      }\n      \n      //now add an edge from each source to each target\n      let edgeType = relation.type;\n      if(edgeType == 'contradictory' ||edgeType == 'contrary'){\n        edgeType = 'attack';\n      }else if(edgeType == 'entails'){\n        edgeType = 'support';\n      }else if(edgeType == 'undercut'){\n        edgeType = 'undercut';\n      }\n      for(let from of froms){\n        for(let to of tos){\n          let edgeId = 'e'+edgeCount;\n          edgeCount++;\n          map.edges.push(new Edge({\n            id:edgeId,\n            from:from, //node\n            to:to, //node\n            fromStatement: fromStatement, //statement\n            toStatement: toStatement, //statement\n            type:edgeType,\n            status: relation.status\n          }));\n        }\n      }\n    }//ends foreach loop of relationsForMap\n\n    //Add support edges to represent equivalence relations between sentences or sentence occurrences\n    //1) From all argument nodes that use p as main conclusion to statement node p\n    //2) From statement node p to all arguments that use p as premise\n    for(let node of map.nodes){\n      if(node.type == 'statement'){\n        let roles = statementRoles[node.title];\n        let statement = data.statements[node.title];\n        if(roles){\n          //1) add conclusion +> statementNode edges\n          for(let argumentNode of roles.conclusionIn){\n            let edgeId = 'e'+edgeCount;\n            edgeCount++;\n            map.edges.push(new Edge({\n              id:edgeId,\n              from:argumentNode, //node\n              to:node, //node\n              fromStatement: statement, //statement\n              toStatement: statement, //statement\n              type:'support',\n              status: 'reconstructed'\n            }));\n          }\n\n          //2) add statementNode +> premise edges\n          for(let argumentNode of roles.premiseIn){\n            let edgeId = 'e'+edgeCount;\n            edgeCount++;\n            map.edges.push(new Edge({\n              id:edgeId,\n              from:node, //node\n              to:argumentNode, //node\n              fromStatement: statement, //statement\n              toStatement: statement, //statement\n              type:'support',\n              status: 'reconstructed'\n            }));\n          }\n        }\n      }\n    }\n    \n    //groups\n    //groups are added to map.nodes\n    //nodes contained within a group are removed from map.nodes and pushed into group.nodes instead.\n    //groups within groups are also pushed to group.nodes.\n    if(this.settings.groupMode && this.settings.groupMode != 'none'){\n      const nodeList = map.nodes;\n      map.nodes = [];\n      \n      const groupDict = {};\n      const groupList = [];\n      \n      let maxGroupLevel = 0;\n      \n      for(let node of nodeList){\n        let section = null;\n        if(node.type == \"argument\"){\n          let argument = data.arguments[node.title];\n          if(argument.section){\n            section = argument.section;\n          }else{\n            for(let member of argument.descriptions){\n              if(member.section){\n                section = member.section;\n                break;\n              }\n            }            \n          }\n        }else{\n          let equivalenceClass = data.statements[node.title];\n          for(let member of equivalenceClass.members){\n            if(member.section){\n              section = member.section;\n              break;\n            }\n          }\n        }\n        \n        if(section){\n          if(maxGroupLevel < section.level){\n            maxGroupLevel = section.level;\n          }\n          let group = groupDict[section.id];\n          if(!group){\n            group = {\n              type: \"group\",\n              id:section.id, \n              title: section.title,\n              labelTitle: section.title,\n              level: section.level, \n              nodes: []\n            };\n            if(section.parent){\n              group.parent = section.parent.id;\n            }\n            groupDict[section.id] = group;\n            groupList.push(group);\n          }\n          group.nodes.push(node);\n        }else{\n          map.nodes.push(node);\n        }\n      }\n      \n      //normalize group levels\n      const minGroupLevel = maxGroupLevel - this.settings.groupDepth + 1;\n      for(let group of groupList){\n        group.level = group.level - minGroupLevel;\n      }\n      for(let group of groupList){\n        if(group.level < 0){\n          for(let node of group.nodes){\n            map.nodes.push(node);\n          }\n        }else{\n          let parentGroup = groupDict[group.parent];\n          if(parentGroup && parentGroup.level >= 0){\n            parentGroup.nodes.push(group);\n          }else{\n            map.nodes.push(group);\n          }          \n        }\n      }\n      \n    }\n\n    return map;\n  }\n}\nmodule.exports = {\n  MapMaker: MapMaker\n}\n"]}